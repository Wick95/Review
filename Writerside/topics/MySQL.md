# MySQL
##  Index-索引

#### 索引是如何工作的？ 
类似一本书的目录，对于想要查找的维度单独构建一个集合，能够定位到相关数据。
#### 索引在MYSQL中哪一层实现的？ 有什么弊端？
在存储引擎层实现的，而不是服务器层实现的。缺点是不同的存储引擎工作方式不同，在索引实现上并没有统一的标准，不是所有存储引擎都支持所有类型的索引。
#### B-Tree是什么？ 有什么特性？ 
B-Tree 指的是平衡树，能够保证对数时间内完成数据的查找。其特点是数据有序，在插入和删除后能够自行调整， 保证每一个叶子页到根的距离相同，使树的高
度尽可能小，适合大数据量的存储系统，如数据库和文件系统。


        // 有什么弊端？
        // 1.联合索引如果不按照从最左列开始查找，则无法使用索引。2.不能跳过索引中的列。3.如果对其中某一列的值做范围查询，则其右边的列无法使用索引。
        // 所以索引的列顺序很重要，优化性能时，我们需要使用相同的多个列，但是顺序不同来满足查询要求。
### Collapsible blocks
// MySQL
//
//1.事务：
//	 数据库事务四大特性？
//	 原子性、一致性、隔离性、持久性
//
//	 隔离级别？
//	 读未提交、读已提交、可重复读、序列化
//
//	 隔离级别如何实现的？
//	 MySQL全表的数据存储在以主键值为排序的B+树索引中，叶子结点存储了相应主键的整行记录，都是最新值，有可能已经提交，有可能未提交。
//
//
//	 什么是幻读： 在一个事务中，后一次查询到了前一次查询没有的数据。
//
//	 如何避免幻读：读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。
//	 			在快照读读情况下，mysql通过mvcc来避免幻读。
//				在当前读读情况下，mysql通过next-key来避免幻读。
//
//	 数据库事务如何实现：隔离性是锁机制 一致性是undo redo日志 原子性是commit 持久性写入磁盘
//
//
//2.锁的概念
//	行锁和间隙锁
//		行锁： 单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身。在索引上加入X锁。
//		间隙锁： 在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁。
//
//	使用表锁？
//		不通过索引条件检索数据时，或者检索范围太大接近全表。表锁
//
//	什么时候使用行锁？
//		当前读，更新、删除。行锁
//
//	如果一张表有多条记录被上gap锁，但这是不可接受的，如何避免或者减小gap锁的影响。
//		减少基于范围的数据检索过滤条件
//
//	意向锁
//		意向锁的存在是为了平衡 行锁和表锁。
//		意向锁是表级别锁。
//
//4.索引
//	什么是索引？
//		索引是一种加快查询速度的数据结构
//
//	聚集索引与非聚集索引
//		聚集索引就是主键索引，每个叶子节点存放着完整的数据。非聚集索引每个叶子节点存放着着主键ID。
//		一个表中存在主键后，整齐排列的数据会转变成平衡树的结构，整个表就变成了一个索引，所以叫做聚集索引。
//		如果没有主键，InnoDB会寻找一个唯一非空索引作为聚集索引，如果没有，则隐式的定义一个主键。
//
//	索引的种类
//		主键索引，唯一索引，普通索引，全文索引
//
//	mysql的复合索引
//		MySQL的复合索引遵循了最左前缀原则。
//		ABC A/AB/ABC
//
//	查询在什么时候不走（预期中的）索引
//		like
//		非最左前缀顺序
//		where order by limit
//		where 对null判断
//		在where查询中使用了or关键字 （Innodb）用UNION替换OR,可以使用索引。
//
//	mysql索引对排序的优化
//		首先order by的条件列满足索引的最左前缀原则 以及where 和order by 组合满足最左前缀原则
//		索引是覆盖索引
//
//	mysql的排序方式
//		index排序： 扫描索引本身完成排序
//		filesort排序：单路排序 直接读取磁盘上的数据进入缓存中，再缓存中重新排序。顺序读取不是随机读取，占用空间比较大。
//					 双路排序，第一次读到索引指向的数据位置，第二次读取位置上的数据。需要两次磁盘IO。
//
//3.主从复制
//	mysql的主从复制有哪些模式？默认使用哪种模式？原理？
//		异步 半同步 全同步
//		1.slave 连接上master时 启动一个log dump线程，读取binlog 加锁。
//		2。slave 的IO线程收到binlog后保存到relaylog中
//		3。sql线程重新执行
//		4、默认 1 分钟同步一次
//
//    mysql5.8相对于以前版本在主从复制上做了哪些改进？
//    	5.7增加了多线程
//    	5.6增加了GTID
//
//    如何使用binlog在系统异常时恢复数据？
//    	show master logs 查看binlog 的日志文件
//    	show master status
//    	fiush logs
//    	mysqlbinlog 命令查看
//    	/usr/bin/mysqlbinlog  --stop-position=435 --database=hello  /var/lib/mysql/mysql-bin.000006 | /usr/bin/mysql -uroot -p密码 -v hello
//
//    mysql的几种主从结构
//    	一主多从 多主一从 多主一从
//
//6.底层：
//	mysql底层数据结构是啥？
//		B+树
//
//	对于行数据存储有几种格式？默认格式是啥？
//		Mysql 目前有4种行格式：Redundant、Compact、Dynamic、Compressed
//		5.6是Compact 5.7是Dynamic
//
//	这几种格式的主要区别是啥？
//		B-tree存储变长列 固定768
//		压缩了空间
//		提高储存容量 支持大索引
//		支持数据和索引的压缩
//
//	如何理解数据页以及为什么使用这种结构。
//		innodb的数据页默认是16kb大小 减少和磁盘的IO次数。
//
//	innoDB里的LRU实现
//		Buffer pool 有三个链表 第一个空闲链表 free 第二个 执行到磁盘上的链表 flush  第三个LRU链表 分为old 和young 3:5的比例，第一次会把数据页放入到old区 如果第二次被访问的时间超过1秒就放入young区。
//
//7.分布式
//	如何保证数据库与缓存一致
//		读：先读缓存 再读数据库 放入缓存中
//		写：先更新数据库，在删除缓存
//
//	数据库分表一般在多大的量才需要
//		1000w
//
//	分库分表带来的分布式困境有哪些？对应策略是啥？
//		事务 数据迁移 排序 分页
//
//8.RC和RR的区别：
//	显然 RR 支持 gap lock(next-key lock)，而RC则没有。因为MySQL的RR需要gaplock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；
//	RC 隔离级别不支持 statement 格式的bin log，因为该格式的复制，会导致主从数据的不一致；
//	RC半一致性读。减少了update语句时行锁的冲突；对于不满足update更新条件的记录，可以提前放锁，减少并发冲突的概率；
//
//9.不同级别下的MVCC的区别：
//	RC：在每次语句执行的过程中，都关闭ReadView，每次重新生成当前状态的ReadView。
//	RR：在创建事务的时候就声称了ReadView,一支维持到事务结束。
//
//数据库优化思路
//	用--log-slow-queries(查询日志)   --log-queries-not-using-indexes(查询未使用索引日志)
//	用explain 或者是desc tableName 解析。
//	查看耗时 set profiling=1。
//
//如何分析慢查询
//	查看慢查询  show status like 'slow_queries'; 设置慢查询时间 show variables like 'long_query_time';
//	expain / 查看slow.log 中的查询时间、锁的时间、影响行数、sql内容
//
//Insert的执行流程
//	执行insert语句，判断是否有和插入意向锁冲突，有加入意向锁，进入锁等待。如果没有直接写数据
//	执行commit Reads 判断是否有其他活跃的事务，如果有给他创建一个X锁 自己进入锁等待 （第一次是快照读，第二次是当前读）
