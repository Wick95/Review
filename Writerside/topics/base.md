//事务四大特性？
//1.原子性：一个事务要不全部执行，要不全都不执行。事务内的查询行为一致。
//2.一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。一致性状态和具体的业务规则有关。库存、转账等。
//3.隔离性：事务之间的操作相互隔离，互不影响。
//4.持久性：事务的操作结果是永久的，事务一旦提交不会随着机器的重启、宕机而消失。

            //什么是数据库隔离级别？
            //1.读未提交 Read Uncommitted。一个事务可以读到另一个事务未提交的数据。 可以产生脏读，即一个事务读到另一个事务未提交的中间态的数据。
            //2.读已提交 Read Committed。 一个事务只能读到另一个事务已提交的数据。 ，可以产生不可重复读，即一个事务中前后两次查询之间其他事务插入了新数据，导致同一条数据两次查询的结果不一致。
            //3.可重复读 Read Repeatable。不会产生不可重复读。可以产生幻读，即一个事务内前后两次相同查询的结果集不同。
            //4.序列化 Serializable。事务之间串行执行。

            //在实际应用中，如何选择合适的隔离级别？
            //请解释一下MySQL的InnoDB存储引擎的默认隔离级别是什么？为什么选择这个隔离级别？
            //可重复读 Read Repeatable。因为可重复读级别能够保证解决脏读和不可重复读的问题，同时又通过间隙锁解决了幻读的问题。在并发性能方面比序列化要快。


            //请解释一下在并发事务中，如何通过锁来实现不同的隔离级别？
            //使用排他锁、共享锁、以及锁释放时机可以实现不同的隔离级别。

            //InnoDB如何实现的不同隔离级别
            //1.读未提交，读不加锁，写加排他锁，可以读到其他事务正在修改但未提交的数据。会产生脏读。
            //2.读已提交，读不加锁，写加排他锁。通过MVCC为每个SQL执行时提供一个数据快照，包含所有已提交事务的修改，解决了脏读问题。但是还是会有不可重复读问题。
            //3.可重复读，读不加锁，写加排他锁。通过MVCC为每个事务提供一个数据快照，事务内的SQL看到的数据都是一致的，解决不可重复读的问题。同时额外使用间隙锁形成NextKey锁解决幻读问题。
            //4.序列化，读加共享锁，写加排他锁。


            //请解释一下什么是乐观锁和悲观锁？它们在实现事务隔离时有什么区别和优劣？
            //请解释一下在分布式数据库中，如何实现事务的隔离性？

//	 分布式事务： 2PC 两端提交。 第一次预提交，如果结果都成功，第二阶段统一提交。
//	 			TCC 解决了2PC单点问题（主从业务方）和同步阻塞（超时机制）
//	 			saga 本地事务备份副本，失败就会滚

//以下三条 sql 如何建索引 WHERE a=1 AND b=1 ，WHERE b=1 ，WHERE b=1 ORDER BY time DESC

//一条select/insert/update语句的执行流程

使用 READ COMMITTED 隔离级别或启用 innodb_locks_unsafe_for_binlog 还会产生其他影响。 MySQL 评估 WHERE 条件后，将释放不匹配行的记录锁。对于 UPDATE 语句， InnoDB 会进行“半一致”读取，从而将最新提交的版本返回给 MySQL，以便 MySQL 可以确定该行是否与 WHERE 的条件。

//XA 事务以及解决并发和死锁问题

//explain 都有哪些内容？
//连接都有哪些类型？ 
const eq_ref ref ref_null index_merge eq_subquery index_subquery range index all 
//Extra info有哪些内容？ 
Using Index 覆盖索引 Using where 范围查找 Using temporary 临时表 Using index condition 索引条件查询 

